AWSTemplateFormatVersion: '2010-09-09'
Description: 'Full Patching Orchestration: Calendar, Start/Stop, Snapshots, and SSM Trigger.'

Parameters:
  PatchingTagKey:
    Type: String
    Default: "patchingphase"
    Description: "The Tag Key to filter instances (e.g., patchingphase)"

Resources:
  # --- IAM ROLE FOR LAMBDAS ---
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: [lambda.amazonaws.com] }
            Action: ['sts:AssumeRole']
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: PatchingPermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: ['ec2:Describe*', 'ec2:StartInstances', 'ec2:StopInstances', 'ec2:CreateSnapshot']
                Resource: '*'
              - Effect: Allow
                Action: ['ssm:SendCommand', 'ssm:GetCommandInvocation']
                Resource: '*'
              - Effect: Allow
                Action: ['sns:Publish']
                Resource: '*'

  # --- 1. CALENDAR LAMBDA ---
  CalendarFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.9
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import calendar, json
          from datetime import datetime
          def get_nth_weekday(y, m, n, wd):
              c = calendar.Calendar(firstweekday=calendar.MONDAY)
              weeks = c.monthdatescalendar(y, m)
              days = [d for w in weeks for d in w if d.weekday() == wd and d.month == m]
              return days[n-1]
          def lambda_handler(event, context):
              now = datetime.now()
              p1 = get_nth_weekday(now.year, now.month, 3, 0) # 3rd Mon
              p2 = get_nth_weekday(now.year, now.month, 3, 3) # 3rd Thu
              return {
                  "patching_plan": [
                      {"phaseName": "phase1", "startTime": p1.strftime('%Y-%m-%dT10:00:00Z')},
                      {"phaseName": "phase2", "startTime": p2.strftime('%Y-%m-%dT10:00:00Z')}
                  ]
              }

  # --- 2. START/STOP LAMBDA ---
  StartStopFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.9
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          TAG_KEY: !Ref PatchingTagKey
      Code:
        ZipFile: |
          import boto3, os
          def lambda_handler(event, context):
              ec2 = boto3.client('ec2')
              phase = event['phaseName']
              tag_key = os.environ['TAG_KEY']
              res = ec2.describe_instances(Filters=[{'Name': f'tag:{tag_key}', 'Values': [phase]}, {'Name': 'instance-state-name', 'Values': ['stopped']}])
              ids = [i['InstanceId'] for r in res['Reservations'] for i in r['Instances']]
              if ids:
                  ec2.start_instances(InstanceIds=ids)
                  return {"instanceStatus": "Starting"}
              return {"instanceStatus": "All instances start"}

  # --- 3. SNAPSHOT LAMBDA ---
  SnapshotFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.9
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          TAG_KEY: !Ref PatchingTagKey
      Code:
        ZipFile: |
          import boto3, os
          def lambda_handler(event, context):
              ec2 = boto3.client('ec2')
              phase, tag_key = event['phaseName'], os.environ['TAG_KEY']
              res = ec2.describe_instances(Filters=[{'Name': f'tag:{tag_key}', 'Values': [phase]}])
              ids = [i['InstanceId'] for r in res['Reservations'] for i in r['Instances']]
              snaps = []
              for inst in ids:
                  vols = ec2.describe_volumes(Filters=[{'Name': 'attachment.instance-id', 'Values': [inst]}])
                  for v in vols['Volumes']:
                      s = ec2.create_snapshot(VolumeId=v['VolumeId'], Description=f"Pre-patch {inst}")
                      snaps.append(s['SnapshotId'])
              return {"snapshotIds": snaps, "phaseName": phase, "startTime": event['startTime']}

  # --- 4. CHECK STATUS LAMBDA ---
  CheckStatusFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.9
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import boto3
          def lambda_handler(event, context):
              ec2 = boto3.client('ec2')
              ids = event.get('snapshotIds', [])
              if not ids: return {"status": "COMPLETE"}
              res = ec2.describe_snapshots(SnapshotIds=ids)
              if all(s['State'] == 'completed' for s in res['snapshots']):
                  return {"status": "COMPLETE"}
              return {"status": "PENDING"}

  # --- 5. SSM TRIGGER LAMBDA ---
  SSMTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.9
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          TAG_KEY: !Ref PatchingTagKey
      Code:
        ZipFile: |
          import boto3, os
          def lambda_handler(event, context):
              ssm = boto3.client('ssm')
              phase, tag_key = event['phaseName'], os.environ['TAG_KEY']
              ssm.send_command(Targets=[{'Key': f'tag:{tag_key}', 'Values': [phase]}], DocumentName='AWS-RunPatchBaseline', Parameters={'Operation': ['Install']})
              return {"status": "Success"}

  # --- STEP FUNCTION (ORCHESTRATOR) ---
  PatchingStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      RoleArn: !GetAtt LambdaExecutionRole.Arn # In prod, use a dedicated SF Role
      DefinitionString: !Sub |
        {
          "StartAt": "Calendar",
          "States": {
            "Calendar": {
              "Type": "Task",
              "Resource": "${CalendarFunction.Arn}",
              "Next": "PhaseIterator"
            },
            "PhaseIterator": {
              "Type": "Map",
              "ItemsPath": "$.patching_plan",
              "MaxConcurrency": 1,
              "Iterator": {
                "StartAt": "StartInstances",
                "States": {
                  "StartInstances": {
                    "Type": "Task",
                    "Resource": "${StartStopFunction.Arn}",
                    "Next": "CheckStartWait"
                  },
                  "CheckStartWait": { "Type": "Wait", "Seconds": 300, "Next": "Snapshot" },
                  "Snapshot": {
                    "Type": "Task",
                    "Resource": "${SnapshotFunction.Arn}",
                    "Next": "PollWait"
                  },
                  "PollWait": { "Type": "Wait", "Seconds": 600, "Next": "CheckStatus" },
                  "CheckStatus": {
                    "Type": "Task",
                    "Resource": "${CheckStatusFunction.Arn}",
                    "Next": "IsComplete"
                  },
                  "IsComplete": {
                    "Type": "Choice",
                    "Choices": [{ "Variable": "$.status", "StringEquals": "COMPLETE", "Next": "FinalWait" }],
                    "Default": "PollWait"
                  },
                  "FinalWait": {
                    "Type": "Wait",
                    "TimestampPath": "$.startTime",
                    "Next": "TriggerSSM"
                  },
                  "TriggerSSM": {
                    "Type": "Task",
                    "Resource": "${SSMTriggerFunction.Arn}",
                    "End": true
                  }
                }
              },
              "End": true
            }
          }
        }